{"ast":null,"code":"// passs in this format: [{process:'1', burstTime'2',arrivalTime:'3',priority:'4'},{process:'1', burstTime'2',arrivalTime:'3',priority:'4'}]\nexport const preemptiveSJF = data => {\n  // const {process, burstTime, arrivalTime} = data;\n  let currentTime = 0;\n  let totalTime = 0;\n  let currentProcess = 0;\n  let firstLine = [];\n  let secondLine = [];\n  let burst = [];\n  let arrival = [];\n  let numProcess = data.length;\n  let arrived = new Array(numProcess).fill(0);\n  let turnaround = new Array(numProcess).fill(0);\n  let waiting = new Array(numProcess).fill(0);\n  let initialArrival = [];\n  let initialBurst = [];\n  let minArrival = Number.MAX_VALUE;\n  let currentBurst = Number.MAX_VALUE; //get array of burstTime and arrivalTime\n\n  data.forEach(element => {\n    burst.push(parseInt(element.burstTime));\n    initialArrival.push(parseInt(element.arrivalTime));\n    arrival.push(parseInt(element.arrivalTime));\n    initialBurst.push(parseInt(element.burstTime));\n  });\n\n  for (let i = 0; i < numProcess; i++) {\n    if (arrival[i] < minArrival) {\n      minArrival = arrival[i];\n    }\n\n    totalTime += burst[i];\n  }\n\n  secondLine.push(minArrival.toString());\n  totalTime += minArrival;\n  currentTime += minArrival;\n\n  for (let i = 0; i < numProcess; ++i) {\n    if (arrival[i] === minArrival) {\n      arrived[i] = 1;\n\n      if (burst[i] <= currentBurst) {\n        currentProcess = i;\n        currentBurst = burst[i];\n      }\n    }\n  }\n\n  while (currentTime <= totalTime) {\n    let previousProcess = currentProcess;\n    let changed = false;\n\n    for (let i = 0; i < numProcess; ++i) {\n      if (arrival[i] === currentTime) {\n        arrived[i] = 1;\n\n        if (burst[i] < currentBurst) {\n          changed = true;\n          currentBurst = burst[i];\n          currentProcess = i;\n        }\n      }\n    }\n\n    if (currentBurst === 0 && !changed) {\n      turnaround[currentProcess] = currentTime - initialArrival[currentProcess];\n      waiting[currentProcess] = turnaround[currentProcess] - initialBurst[currentProcess];\n      let minBurst = Number.MAX_VALUE;\n      let minProcess = -1;\n\n      for (let i = 0; i < numProcess; ++i) {\n        if (arrived[i] === 1 && burst[i] < minBurst && burst[i] !== 0) {\n          minBurst = burst[i];\n          minProcess = i;\n        }\n      }\n\n      currentProcess = minProcess;\n      currentBurst = minBurst;\n      changed = true;\n    }\n\n    if (changed) {\n      firstLine.push(\"P\" + previousProcess.toString());\n\n      if (true) {\n        secondLine.push(currentTime.toString());\n      }\n\n      if (currentTime >= totalTime) {\n        break;\n      }\n    }\n\n    currentTime++;\n    burst[currentProcess]--;\n    currentBurst--;\n  }\n\n  let avgTurnAround = 0;\n  let avgWaiting = 0;\n\n  for (let i = 0; i < numProcess; i++) {\n    avgTurnAround += turnaround[i];\n    avgWaiting += waiting[i];\n  }\n\n  avgTurnAround /= numProcess;\n  avgWaiting /= numProcess;\n  const output = {\n    processSequence: firstLine,\n    timeSequence: secondLine,\n    avgTurnAround: avgTurnAround.toFixed(4),\n    avgWaiting: avgWaiting.toFixed(4),\n    turnAround: turnaround,\n    waiting: waiting\n  };\n  return output;\n};","map":{"version":3,"sources":["/home/skessler/Programming/CPU_Scheduling_simulator/cpu-scheduling-simulator/src/screens/Landing/algorithms/preemptive_sjf/index.tsx"],"names":["preemptiveSJF","data","currentTime","totalTime","currentProcess","firstLine","secondLine","burst","arrival","numProcess","length","arrived","Array","fill","turnaround","waiting","initialArrival","initialBurst","minArrival","Number","MAX_VALUE","currentBurst","forEach","element","push","parseInt","burstTime","arrivalTime","i","toString","previousProcess","changed","minBurst","minProcess","avgTurnAround","avgWaiting","output","processSequence","timeSequence","toFixed","turnAround"],"mappings":"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","sourcesContent":["// passs in this format: [{process:'1', burstTime'2',arrivalTime:'3',priority:'4'},{process:'1', burstTime'2',arrivalTime:'3',priority:'4'}]\nexport const preemptiveSJF = (data: any) => {\n\t// const {process, burstTime, arrivalTime} = data;\n\n\tlet currentTime: number = 0;\n\tlet totalTime: number = 0;\n    let currentProcess:number = 0;\n\tlet firstLine:string[] = [];\n\tlet secondLine: string[] = [];\n\tlet burst: number[] = [];\n\tlet arrival: number[] = [];\n\tlet numProcess = data.length;\n\tlet arrived: number[] = new Array(numProcess).fill(0);\n\tlet turnaround: number[] = new Array(numProcess).fill(0);\n\tlet waiting: number[] = new Array(numProcess).fill(0);\n\tlet initialArrival: number[] = [];\n\tlet initialBurst: number[] = [];\n\tlet minArrival:number = Number.MAX_VALUE;\n    let currentBurst:number= Number.MAX_VALUE;\n\n\t//get array of burstTime and arrivalTime\n\tdata.forEach((element: any) => {\n\t\tburst.push(parseInt(element.burstTime));\n\t\tinitialArrival.push(parseInt(element.arrivalTime));\n\t\tarrival.push(parseInt(element.arrivalTime));\n\t\tinitialBurst.push(parseInt(element.burstTime));\n\t});\n\n\tfor (let i = 0; i < numProcess; i++) {\n\t\tif (arrival[i] < minArrival) {\n\t\t\tminArrival = arrival[i];\n\t\t}\n\t\ttotalTime += burst[i];\n\t}\n\tsecondLine.push(minArrival.toString());\n\ttotalTime += minArrival;\n\tcurrentTime += minArrival;\n    for(let i = 0; i < numProcess; ++i)\n    {\n        if(arrival[i] === minArrival)\n        {\n            arrived[i] = 1;\n            if(burst[i] <= currentBurst)\n            {\n                currentProcess = i;\n                currentBurst = burst[i];\n            }\n        }\n    }\n\n\twhile (currentTime <= totalTime) {\n\n        let previousProcess:number = currentProcess;\n        let changed:boolean = false;\n\n\t\tfor(let i = 0; i < numProcess; ++i)\n        {\n            if(arrival[i] === currentTime)\n            {\n                arrived[i] = 1;\n                if(burst[i] < currentBurst)\n                {\n                    changed = true;\n                    currentBurst = burst[i];\n                    currentProcess = i;\n                }\n            }\n        }\n\n\t\tif(currentBurst === 0 && !changed)\n        {\n            turnaround[currentProcess] = currentTime - initialArrival[currentProcess];\n            waiting[currentProcess] = turnaround[currentProcess] - initialBurst[currentProcess];\n            let minBurst:number = Number.MAX_VALUE;\n            let minProcess:number = -1;\n            for(let i = 0; i < numProcess; ++i)\n            {\n                if(arrived[i] === 1 && burst[i] < minBurst && burst[i] !== 0)\n                {\n                    minBurst = burst[i];\n                    minProcess = i;\n                }\n            }\n            currentProcess = minProcess;\n            currentBurst = minBurst;\n            changed = true;\n        }\n        if(changed)\n        {\n            firstLine.push(\"P\"+(previousProcess).toString());\n            if(true)\n            {\n                secondLine.push(currentTime.toString());\n            }\n            if(currentTime >= totalTime)\n            {\n                break;\n            }\n        }\n        currentTime++;\n        burst[currentProcess]--;\n        currentBurst--;\n\t}\n\n\tlet avgTurnAround:number = 0;\n\tlet avgWaiting:number = 0;\n\tfor (let i = 0; i < numProcess; i++) {\n\t\tavgTurnAround += turnaround[i];\n\t\tavgWaiting += waiting[i];\n\t}\n\tavgTurnAround /= numProcess;\n\tavgWaiting /= numProcess;\n\n\tconst output = {\n\t\tprocessSequence: firstLine,\n\t\ttimeSequence: secondLine,\n\t\tavgTurnAround: avgTurnAround.toFixed(4),\n\t\tavgWaiting: avgWaiting.toFixed(4),\n\t\tturnAround: turnaround,\n\t\twaiting: waiting\n\t};\n\n\treturn output;\n};\n"]},"metadata":{},"sourceType":"module"}