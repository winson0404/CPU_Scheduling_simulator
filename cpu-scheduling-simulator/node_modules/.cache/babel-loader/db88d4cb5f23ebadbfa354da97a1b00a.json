{"ast":null,"code":"// passs in this format: [{process:'1', burstTime'2',arrivalTime:'3',priority:'4'},{process:'1', burstTime'2',arrivalTime:'3',priority:'4'}]\nexport const nonPreemptivePriority = data => {\n  // const {process, burstTime, arrivalTime} = data;\n  let currentTime = 0;\n  let totalTime = 0;\n  let firstLine = [];\n  let secondLine = [];\n  let burst = [];\n  let priority = [];\n  let arrival = [];\n  let numProcess = data.length;\n  let arrived = new Array(numProcess).fill(0);\n  let turnaround = new Array(numProcess).fill(0);\n  let waiting = new Array(numProcess).fill(0);\n  let initialArrival = [];\n  let initialBurst = [];\n  let minArrival = Number.MAX_VALUE; //get array of burstTime and arrivalTime\n\n  data.forEach(element => {\n    burst.push(parseInt(element.burstTime));\n    initialArrival.push(parseInt(element.arrivalTime));\n    arrival.push(parseInt(element.arrivalTime));\n    initialBurst.push(parseInt(element.burstTime));\n    priority.push(parseInt(element.priority));\n  });\n\n  for (let i = 0; i < numProcess; ++i) {\n    if (arrival[i] < minArrival) {\n      minArrival = arrival[i];\n    }\n\n    totalTime += burst[i];\n    arrived[i] = -1;\n  }\n\n  secondLine.push(minArrival.toString());\n  totalTime += minArrival;\n  currentTime += minArrival;\n\n  while (currentTime < totalTime) {\n    for (let i = 0; i < numProcess; ++i) {\n      if (arrival[i] <= currentTime) {\n        arrived[i] = priority[i];\n      }\n    }\n\n    let minPriority = Number.MAX_VALUE;\n    let minIndex = 0;\n\n    for (let i = 0; i < numProcess; ++i) {\n      if (burst[i] !== 0 && arrived[i] < minPriority && arrived[i] !== -1) {\n        minPriority = arrived[i];\n        minIndex = i;\n      }\n    }\n\n    currentTime += burst[minIndex];\n    turnaround[minIndex] = currentTime - initialArrival[minIndex];\n    waiting[minIndex] = turnaround[minIndex] - initialBurst[minIndex];\n    burst[minIndex] = 0;\n    firstLine.push(\"P\" + minIndex.toString());\n    secondLine.push(currentTime.toString());\n  }\n\n  let avgTurnAround = 0;\n  let avgWaiting = 0;\n\n  for (let i = 0; i < numProcess; i++) {\n    avgTurnAround += turnaround[i];\n    avgWaiting += waiting[i];\n  }\n\n  avgTurnAround /= numProcess;\n  avgWaiting /= numProcess;\n  const output = {\n    processSequence: firstLine,\n    timeSequence: secondLine,\n    avgTurnAround: avgTurnAround.toFixed(4),\n    avgWaiting: avgWaiting.toFixed(4),\n    turnAround: turnaround,\n    waiting: waiting\n  };\n  return output;\n};","map":{"version":3,"sources":["/home/skessler/Programming/CPU_Scheduling_simulator/cpu-scheduling-simulator/src/screens/Landing/algorithms/non_preemptive_priority/index.tsx"],"names":["nonPreemptivePriority","data","currentTime","totalTime","firstLine","secondLine","burst","priority","arrival","numProcess","length","arrived","Array","fill","turnaround","waiting","initialArrival","initialBurst","minArrival","Number","MAX_VALUE","forEach","element","push","parseInt","burstTime","arrivalTime","i","toString","minPriority","minIndex","avgTurnAround","avgWaiting","output","processSequence","timeSequence","toFixed","turnAround"],"mappings":"AAAA;AACA,OAAO,MAAMA,qBAAqB,GAAIC,IAAD,IAAe;AACnD;AAEA,MAAIC,WAAmB,GAAG,CAA1B;AACA,MAAIC,SAAiB,GAAG,CAAxB;AACA,MAAIC,SAAkB,GAAG,EAAzB;AACA,MAAIC,UAAoB,GAAG,EAA3B;AACA,MAAIC,KAAe,GAAG,EAAtB;AACG,MAAIC,QAAkB,GAAG,EAAzB;AACH,MAAIC,OAAiB,GAAG,EAAxB;AACA,MAAIC,UAAU,GAAGR,IAAI,CAACS,MAAtB;AACA,MAAIC,OAAiB,GAAG,IAAIC,KAAJ,CAAUH,UAAV,EAAsBI,IAAtB,CAA2B,CAA3B,CAAxB;AACA,MAAIC,UAAoB,GAAG,IAAIF,KAAJ,CAAUH,UAAV,EAAsBI,IAAtB,CAA2B,CAA3B,CAA3B;AACA,MAAIE,OAAiB,GAAG,IAAIH,KAAJ,CAAUH,UAAV,EAAsBI,IAAtB,CAA2B,CAA3B,CAAxB;AACA,MAAIG,cAAwB,GAAG,EAA/B;AACA,MAAIC,YAAsB,GAAG,EAA7B;AACA,MAAIC,UAAiB,GAAGC,MAAM,CAACC,SAA/B,CAhBmD,CAkBnD;;AACAnB,EAAAA,IAAI,CAACoB,OAAL,CAAcC,OAAD,IAAkB;AAC9BhB,IAAAA,KAAK,CAACiB,IAAN,CAAWC,QAAQ,CAACF,OAAO,CAACG,SAAT,CAAnB;AACAT,IAAAA,cAAc,CAACO,IAAf,CAAoBC,QAAQ,CAACF,OAAO,CAACI,WAAT,CAA5B;AACAlB,IAAAA,OAAO,CAACe,IAAR,CAAaC,QAAQ,CAACF,OAAO,CAACI,WAAT,CAArB;AACAT,IAAAA,YAAY,CAACM,IAAb,CAAkBC,QAAQ,CAACF,OAAO,CAACG,SAAT,CAA1B;AACMlB,IAAAA,QAAQ,CAACgB,IAAT,CAAcC,QAAQ,CAACF,OAAO,CAACf,QAAT,CAAtB;AACN,GAND;;AAQA,OAAI,IAAIoB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGlB,UAAnB,EAA+B,EAAEkB,CAAjC,EACG;AACI,QAAGnB,OAAO,CAACmB,CAAD,CAAP,GAAaT,UAAhB,EACA;AACIA,MAAAA,UAAU,GAAGV,OAAO,CAACmB,CAAD,CAApB;AACH;;AACDxB,IAAAA,SAAS,IAAIG,KAAK,CAACqB,CAAD,CAAlB;AACAhB,IAAAA,OAAO,CAACgB,CAAD,CAAP,GAAa,CAAC,CAAd;AACH;;AACJtB,EAAAA,UAAU,CAACkB,IAAX,CAAgBL,UAAU,CAACU,QAAX,EAAhB;AACAzB,EAAAA,SAAS,IAAIe,UAAb;AACAhB,EAAAA,WAAW,IAAIgB,UAAf;;AAEA,SAAMhB,WAAW,GAAGC,SAApB,EACG;AACI,SAAI,IAAIwB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGlB,UAAnB,EAA+B,EAAEkB,CAAjC,EACA;AACI,UAAGnB,OAAO,CAACmB,CAAD,CAAP,IAAczB,WAAjB,EACA;AACIS,QAAAA,OAAO,CAACgB,CAAD,CAAP,GAAapB,QAAQ,CAACoB,CAAD,CAArB;AACH;AACJ;;AAED,QAAIE,WAAkB,GAAEV,MAAM,CAACC,SAA/B;AACA,QAAIU,QAAe,GAAG,CAAtB;;AACA,SAAI,IAAIH,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGlB,UAAnB,EAA+B,EAAEkB,CAAjC,EACA;AACI,UAAGrB,KAAK,CAACqB,CAAD,CAAL,KAAa,CAAb,IAAkBhB,OAAO,CAACgB,CAAD,CAAP,GAAaE,WAA/B,IAA8ClB,OAAO,CAACgB,CAAD,CAAP,KAAe,CAAC,CAAjE,EACA;AACIE,QAAAA,WAAW,GAAGlB,OAAO,CAACgB,CAAD,CAArB;AACAG,QAAAA,QAAQ,GAAGH,CAAX;AACH;AACJ;;AACDzB,IAAAA,WAAW,IAAII,KAAK,CAACwB,QAAD,CAApB;AACAhB,IAAAA,UAAU,CAACgB,QAAD,CAAV,GAAuB5B,WAAW,GAAGc,cAAc,CAACc,QAAD,CAAnD;AACAf,IAAAA,OAAO,CAACe,QAAD,CAAP,GAAoBhB,UAAU,CAACgB,QAAD,CAAV,GAAuBb,YAAY,CAACa,QAAD,CAAvD;AACAxB,IAAAA,KAAK,CAACwB,QAAD,CAAL,GAAkB,CAAlB;AAEA1B,IAAAA,SAAS,CAACmB,IAAV,CAAe,MAAIO,QAAQ,CAACF,QAAT,EAAnB;AACAvB,IAAAA,UAAU,CAACkB,IAAX,CAAgBrB,WAAW,CAAC0B,QAAZ,EAAhB;AACH;;AAEJ,MAAIG,aAAoB,GAAG,CAA3B;AACA,MAAIC,UAAiB,GAAG,CAAxB;;AACA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,UAApB,EAAgCkB,CAAC,EAAjC,EAAqC;AACpCI,IAAAA,aAAa,IAAIjB,UAAU,CAACa,CAAD,CAA3B;AACAK,IAAAA,UAAU,IAAIjB,OAAO,CAACY,CAAD,CAArB;AACA;;AACDI,EAAAA,aAAa,IAAItB,UAAjB;AACAuB,EAAAA,UAAU,IAAIvB,UAAd;AAEA,QAAMwB,MAAM,GAAG;AACdC,IAAAA,eAAe,EAAE9B,SADH;AAEd+B,IAAAA,YAAY,EAAE9B,UAFA;AAGd0B,IAAAA,aAAa,EAAEA,aAAa,CAACK,OAAd,CAAsB,CAAtB,CAHD;AAIdJ,IAAAA,UAAU,EAAEA,UAAU,CAACI,OAAX,CAAmB,CAAnB,CAJE;AAKdC,IAAAA,UAAU,EAAEvB,UALE;AAMdC,IAAAA,OAAO,EAAEA;AANK,GAAf;AASA,SAAOkB,MAAP;AACA,CAxFM","sourcesContent":["// passs in this format: [{process:'1', burstTime'2',arrivalTime:'3',priority:'4'},{process:'1', burstTime'2',arrivalTime:'3',priority:'4'}]\nexport const nonPreemptivePriority = (data: any) => {\n\t// const {process, burstTime, arrivalTime} = data;\n\n\tlet currentTime: number = 0;\n\tlet totalTime: number = 0;\n\tlet firstLine:string[] = [];\n\tlet secondLine: string[] = [];\n\tlet burst: number[] = [];\n    let priority: number[] = [];\n\tlet arrival: number[] = [];\n\tlet numProcess = data.length;\n\tlet arrived: number[] = new Array(numProcess).fill(0);\n\tlet turnaround: number[] = new Array(numProcess).fill(0);\n\tlet waiting: number[] = new Array(numProcess).fill(0);\n\tlet initialArrival: number[] = [];\n\tlet initialBurst: number[] = [];\n\tlet minArrival:number = Number.MAX_VALUE;\n\n\t//get array of burstTime and arrivalTime\n\tdata.forEach((element: any) => {\n\t\tburst.push(parseInt(element.burstTime));\n\t\tinitialArrival.push(parseInt(element.arrivalTime));\n\t\tarrival.push(parseInt(element.arrivalTime));\n\t\tinitialBurst.push(parseInt(element.burstTime));\n        priority.push(parseInt(element.priority))\n\t});\n\n\tfor(let i = 0; i < numProcess; ++i)\n    {\n        if(arrival[i] < minArrival)\n        {\n            minArrival = arrival[i];\n        }\n        totalTime += burst[i];\n        arrived[i] = -1;\n    }\n\tsecondLine.push(minArrival.toString());\n\ttotalTime += minArrival;\n\tcurrentTime += minArrival;\n\n\twhile(currentTime < totalTime)\n    {\n        for(let i = 0; i < numProcess; ++i)\n        {\n            if(arrival[i] <= currentTime)\n            {\n                arrived[i] = priority[i];\n            }\n        }\n\n        let minPriority:number= Number.MAX_VALUE;\n        let minIndex:number = 0;\n        for(let i = 0; i < numProcess; ++i)\n        {\n            if(burst[i] !== 0 && arrived[i] < minPriority && arrived[i] !== -1)\n            {\n                minPriority = arrived[i];\n                minIndex = i;\n            }\n        }\n        currentTime += burst[minIndex];\n        turnaround[minIndex] = currentTime - initialArrival[minIndex];\n        waiting[minIndex] = turnaround[minIndex] - initialBurst[minIndex];\n        burst[minIndex] = 0;\n\n        firstLine.push(\"P\"+minIndex.toString());\n        secondLine.push(currentTime.toString());\n    }\n\n\tlet avgTurnAround:number = 0;\n\tlet avgWaiting:number = 0;\n\tfor (let i = 0; i < numProcess; i++) {\n\t\tavgTurnAround += turnaround[i];\n\t\tavgWaiting += waiting[i];\n\t}\n\tavgTurnAround /= numProcess;\n\tavgWaiting /= numProcess;\n\n\tconst output = {\n\t\tprocessSequence: firstLine,\n\t\ttimeSequence: secondLine,\n\t\tavgTurnAround: avgTurnAround.toFixed(4),\n\t\tavgWaiting: avgWaiting.toFixed(4),\n\t\tturnAround: turnaround,\n\t\twaiting: waiting\n\t};\n\n\treturn output;\n};\n"]},"metadata":{},"sourceType":"module"}