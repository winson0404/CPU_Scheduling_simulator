{"ast":null,"code":"// passs in this format: [{process:'1', burstTime'2',arrivalTime:'3',priority:'4'},{process:'1', burstTime'2',arrivalTime:'3',priority:'4'}]\nexport const nonPreemptiveSJF = data => {\n  // const {process, burstTime, arrivalTime} = data;\n  let currentTime = 0;\n  let totalTime = 0;\n  let firstLine = [];\n  let secondLine = [];\n  let burst = [];\n  let arrival = [];\n  let numProcess = data.length;\n  let arrived = new Array(numProcess).fill(0);\n  let turnaround = new Array(numProcess).fill(0);\n  let waiting = new Array(numProcess).fill(0);\n  let initialArrival = [];\n  let initialBurst = [];\n  let minArrival = Number.MAX_VALUE; //get array of burstTime and arrivalTime\n\n  data.forEach(element => {\n    burst.push(parseInt(element.burstTime));\n    initialArrival.push(parseInt(element.arrivalTime));\n    arrival.push(parseInt(element.arrivalTime));\n    initialBurst.push(parseInt(element.burstTime));\n  });\n\n  for (let i = 0; i < numProcess; i++) {\n    if (arrival[i] < minArrival) {\n      minArrival = arrival[i];\n    }\n\n    totalTime += burst[i];\n  }\n\n  secondLine.push(minArrival.toString());\n  totalTime += minArrival;\n  currentTime += minArrival;\n\n  while (currentTime < totalTime) {\n    for (let i = 0; i < numProcess; i++) {\n      if (arrival[i] <= currentTime) {\n        arrived[i] = burst[i];\n      }\n    }\n\n    let minBurst = Number.MAX_VALUE;\n    let minIndex = 0;\n\n    for (let i = 0; i < numProcess; i++) {\n      if (arrived[i] !== 0 && arrived[i] < minBurst) {\n        minBurst = arrived[i];\n        minIndex = i;\n      }\n    }\n\n    currentTime += minBurst;\n    turnaround[minIndex] = currentTime - initialArrival[minIndex];\n    waiting[minIndex] = turnaround[minIndex] - initialBurst[minIndex];\n    burst[minIndex] = 0;\n    firstLine.push(\"P\" + minIndex.toString());\n    secondLine.push(currentTime.toString());\n  }\n\n  let avgTurnAround = 0;\n  let avgWaiting = 0;\n\n  for (let i = 0; i < numProcess; i++) {\n    avgTurnAround += turnaround[i];\n    avgWaiting += waiting[i];\n  }\n\n  avgTurnAround /= numProcess;\n  avgWaiting /= numProcess;\n  const output = {\n    processSequence: firstLine,\n    timeSequence: secondLine,\n    avgTurnAround: avgTurnAround.toFixed(2),\n    avgWaiting: avgWaiting.toFixed(2),\n    turnAround: turnaround,\n    waiting: waiting\n  };\n  return output;\n};","map":{"version":3,"sources":["/home/skessler/Programming/CPU_Scheduling_simulator/cpu-scheduling-simulator/src/screens/Landing/algorithms/non_preemptive_sjf/index.tsx"],"names":["nonPreemptiveSJF","data","currentTime","totalTime","firstLine","secondLine","burst","arrival","numProcess","length","arrived","Array","fill","turnaround","waiting","initialArrival","initialBurst","minArrival","Number","MAX_VALUE","forEach","element","push","parseInt","burstTime","arrivalTime","i","toString","minBurst","minIndex","avgTurnAround","avgWaiting","output","processSequence","timeSequence","toFixed","turnAround"],"mappings":"AAAA;AACA,OAAO,MAAMA,gBAAgB,GAAIC,IAAD,IAAe;AAC9C;AAEA,MAAIC,WAAmB,GAAG,CAA1B;AACA,MAAIC,SAAiB,GAAG,CAAxB;AACA,MAAIC,SAAkB,GAAG,EAAzB;AACA,MAAIC,UAAoB,GAAG,EAA3B;AACA,MAAIC,KAAe,GAAG,EAAtB;AACA,MAAIC,OAAiB,GAAG,EAAxB;AACA,MAAIC,UAAU,GAAGP,IAAI,CAACQ,MAAtB;AACA,MAAIC,OAAiB,GAAG,IAAIC,KAAJ,CAAUH,UAAV,EAAsBI,IAAtB,CAA2B,CAA3B,CAAxB;AACA,MAAIC,UAAoB,GAAG,IAAIF,KAAJ,CAAUH,UAAV,EAAsBI,IAAtB,CAA2B,CAA3B,CAA3B;AACA,MAAIE,OAAiB,GAAG,IAAIH,KAAJ,CAAUH,UAAV,EAAsBI,IAAtB,CAA2B,CAA3B,CAAxB;AACA,MAAIG,cAAwB,GAAG,EAA/B;AACA,MAAIC,YAAsB,GAAG,EAA7B;AACA,MAAIC,UAAiB,GAAGC,MAAM,CAACC,SAA/B,CAf8C,CAiB9C;;AACAlB,EAAAA,IAAI,CAACmB,OAAL,CAAcC,OAAD,IAAkB;AAC9Bf,IAAAA,KAAK,CAACgB,IAAN,CAAWC,QAAQ,CAACF,OAAO,CAACG,SAAT,CAAnB;AACAT,IAAAA,cAAc,CAACO,IAAf,CAAoBC,QAAQ,CAACF,OAAO,CAACI,WAAT,CAA5B;AACAlB,IAAAA,OAAO,CAACe,IAAR,CAAaC,QAAQ,CAACF,OAAO,CAACI,WAAT,CAArB;AACAT,IAAAA,YAAY,CAACM,IAAb,CAAkBC,QAAQ,CAACF,OAAO,CAACG,SAAT,CAA1B;AACA,GALD;;AAOA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,UAApB,EAAgCkB,CAAC,EAAjC,EAAqC;AACpC,QAAInB,OAAO,CAACmB,CAAD,CAAP,GAAaT,UAAjB,EAA6B;AAC5BA,MAAAA,UAAU,GAAGV,OAAO,CAACmB,CAAD,CAApB;AACA;;AACDvB,IAAAA,SAAS,IAAIG,KAAK,CAACoB,CAAD,CAAlB;AACA;;AACDrB,EAAAA,UAAU,CAACiB,IAAX,CAAgBL,UAAU,CAACU,QAAX,EAAhB;AACAxB,EAAAA,SAAS,IAAIc,UAAb;AACAf,EAAAA,WAAW,IAAIe,UAAf;;AAEA,SAAOf,WAAW,GAAGC,SAArB,EAAgC;AAC/B,SAAK,IAAIuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,UAApB,EAAgCkB,CAAC,EAAjC,EAAqC;AACpC,UAAInB,OAAO,CAACmB,CAAD,CAAP,IAAcxB,WAAlB,EAA+B;AAC9BQ,QAAAA,OAAO,CAACgB,CAAD,CAAP,GAAapB,KAAK,CAACoB,CAAD,CAAlB;AACA;AACD;;AAED,QAAIE,QAAQ,GAAGV,MAAM,CAACC,SAAtB;AACA,QAAIU,QAAQ,GAAG,CAAf;;AACA,SAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,UAApB,EAAgCkB,CAAC,EAAjC,EAAqC;AACpC,UAAIhB,OAAO,CAACgB,CAAD,CAAP,KAAe,CAAf,IAAoBhB,OAAO,CAACgB,CAAD,CAAP,GAAaE,QAArC,EAA+C;AAC9CA,QAAAA,QAAQ,GAAGlB,OAAO,CAACgB,CAAD,CAAlB;AACAG,QAAAA,QAAQ,GAAGH,CAAX;AACA;AACD;;AACDxB,IAAAA,WAAW,IAAI0B,QAAf;AACAf,IAAAA,UAAU,CAACgB,QAAD,CAAV,GAAuB3B,WAAW,GAAGa,cAAc,CAACc,QAAD,CAAnD;AACAf,IAAAA,OAAO,CAACe,QAAD,CAAP,GAAoBhB,UAAU,CAACgB,QAAD,CAAV,GAAuBb,YAAY,CAACa,QAAD,CAAvD;AACAvB,IAAAA,KAAK,CAACuB,QAAD,CAAL,GAAkB,CAAlB;AAEAzB,IAAAA,SAAS,CAACkB,IAAV,CAAe,MAAKO,QAAD,CAAWF,QAAX,EAAnB;AACAtB,IAAAA,UAAU,CAACiB,IAAX,CAAgBpB,WAAW,CAACyB,QAAZ,EAAhB;AACA;;AAED,MAAIG,aAAa,GAAG,CAApB;AACA,MAAIC,UAAU,GAAG,CAAjB;;AACA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,UAApB,EAAgCkB,CAAC,EAAjC,EAAqC;AACpCI,IAAAA,aAAa,IAAIjB,UAAU,CAACa,CAAD,CAA3B;AACAK,IAAAA,UAAU,IAAIjB,OAAO,CAACY,CAAD,CAArB;AACA;;AACDI,EAAAA,aAAa,IAAItB,UAAjB;AACAuB,EAAAA,UAAU,IAAIvB,UAAd;AAEA,QAAMwB,MAAM,GAAG;AACdC,IAAAA,eAAe,EAAE7B,SADH;AAEd8B,IAAAA,YAAY,EAAE7B,UAFA;AAGdyB,IAAAA,aAAa,EAAEA,aAAa,CAACK,OAAd,CAAsB,CAAtB,CAHD;AAIdJ,IAAAA,UAAU,EAAEA,UAAU,CAACI,OAAX,CAAmB,CAAnB,CAJE;AAKdC,IAAAA,UAAU,EAAEvB,UALE;AAMdC,IAAAA,OAAO,EAAEA;AANK,GAAf;AASA,SAAOkB,MAAP;AACA,CA9EM","sourcesContent":["// passs in this format: [{process:'1', burstTime'2',arrivalTime:'3',priority:'4'},{process:'1', burstTime'2',arrivalTime:'3',priority:'4'}]\nexport const nonPreemptiveSJF = (data: any) => {\n\t// const {process, burstTime, arrivalTime} = data;\n\n\tlet currentTime: number = 0;\n\tlet totalTime: number = 0;\n\tlet firstLine:string[] = [];\n\tlet secondLine: string[] = [];\n\tlet burst: number[] = [];\n\tlet arrival: number[] = [];\n\tlet numProcess = data.length;\n\tlet arrived: number[] = new Array(numProcess).fill(0);\n\tlet turnaround: number[] = new Array(numProcess).fill(0);\n\tlet waiting: number[] = new Array(numProcess).fill(0);\n\tlet initialArrival: number[] = [];\n\tlet initialBurst: number[] = [];\n\tlet minArrival:number = Number.MAX_VALUE;\n\n\t//get array of burstTime and arrivalTime\n\tdata.forEach((element: any) => {\n\t\tburst.push(parseInt(element.burstTime));\n\t\tinitialArrival.push(parseInt(element.arrivalTime));\n\t\tarrival.push(parseInt(element.arrivalTime));\n\t\tinitialBurst.push(parseInt(element.burstTime));\n\t});\n\n\tfor (let i = 0; i < numProcess; i++) {\n\t\tif (arrival[i] < minArrival) {\n\t\t\tminArrival = arrival[i];\n\t\t}\n\t\ttotalTime += burst[i];\n\t}\n\tsecondLine.push(minArrival.toString());\n\ttotalTime += minArrival;\n\tcurrentTime += minArrival;\n\n\twhile (currentTime < totalTime) {\n\t\tfor (let i = 0; i < numProcess; i++) {\n\t\t\tif (arrival[i] <= currentTime) {\n\t\t\t\tarrived[i] = burst[i];\n\t\t\t}\n\t\t}\n\n\t\tlet minBurst = Number.MAX_VALUE;\n\t\tlet minIndex = 0;\n\t\tfor (let i = 0; i < numProcess; i++) {\n\t\t\tif (arrived[i] !== 0 && arrived[i] < minBurst) {\n\t\t\t\tminBurst = arrived[i];\n\t\t\t\tminIndex = i;\n\t\t\t}\n\t\t}\n\t\tcurrentTime += minBurst;\n\t\tturnaround[minIndex] = currentTime - initialArrival[minIndex];\n\t\twaiting[minIndex] = turnaround[minIndex] - initialBurst[minIndex];\n\t\tburst[minIndex] = 0;\n\n\t\tfirstLine.push(\"P\"+(minIndex).toString());\n\t\tsecondLine.push(currentTime.toString());\n\t}\n\n\tlet avgTurnAround = 0;\n\tlet avgWaiting = 0;\n\tfor (let i = 0; i < numProcess; i++) {\n\t\tavgTurnAround += turnaround[i];\n\t\tavgWaiting += waiting[i];\n\t}\n\tavgTurnAround /= numProcess;\n\tavgWaiting /= numProcess;\n\n\tconst output = {\n\t\tprocessSequence: firstLine,\n\t\ttimeSequence: secondLine,\n\t\tavgTurnAround: avgTurnAround.toFixed(2),\n\t\tavgWaiting: avgWaiting.toFixed(2),\n\t\tturnAround: turnaround,\n\t\twaiting: waiting\n\t};\n\n\treturn output;\n};\n"]},"metadata":{},"sourceType":"module"}