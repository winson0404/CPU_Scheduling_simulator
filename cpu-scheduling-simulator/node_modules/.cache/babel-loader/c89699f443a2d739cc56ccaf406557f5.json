{"ast":null,"code":"// passs in this format: [{process:'1', burstTime'2',arrivalTime:'3',priority:'4'},{process:'1', burstTime'2',arrivalTime:'3',priority:'4'}]\nexport const preemptivePriority = data => {\n  // const {process, burstTime, arrivalTime} = data;\n  let currentTime = 0;\n  let totalTime = 0;\n  let currentProcess = -1;\n  let firstLine = [];\n  let secondLine = [];\n  let burst = [];\n  let priority = [];\n  let arrival = [];\n  let numProcess = data.length;\n  let arrived = new Array(numProcess).fill(0);\n  let turnaround = new Array(numProcess).fill(0);\n  let waiting = new Array(numProcess).fill(0);\n  let initialArrival = [];\n  let initialBurst = [];\n  let minArrival = Number.MAX_VALUE;\n  let currentPriority = Number.MAX_VALUE;\n  let currentBurst = Number.MAX_VALUE; //get array of burstTime and arrivalTime\n\n  data.forEach(element => {\n    burst.push(parseInt(element.burstTime));\n    initialArrival.push(parseInt(element.arrivalTime));\n    arrival.push(parseInt(element.arrivalTime));\n    initialBurst.push(parseInt(element.burstTime));\n    priority.push(parseInt(element.priority));\n  });\n\n  for (let i = 0; i < numProcess; ++i) {\n    if (arrival[i] < minArrival) {\n      minArrival = arrival[i];\n    }\n\n    totalTime += burst[i];\n    arrived[i] = -1;\n  }\n\n  secondLine.push(minArrival.toString());\n  totalTime += minArrival;\n  currentTime += minArrival;\n\n  for (let i = 0; i < numProcess; ++i) {\n    if (arrival[i] === minArrival) {\n      arrived[i] = 1;\n\n      if (priority[i] <= currentPriority) {\n        currentProcess = i;\n        currentBurst = burst[i];\n        currentPriority = priority[i];\n      }\n    }\n  }\n\n  while (currentTime <= totalTime) {\n    let previousProcess = currentProcess;\n    let changed = false;\n\n    for (let i = 0; i < numProcess; ++i) {\n      if (arrival[i] === currentTime) {\n        arrived[i] = 1;\n\n        if (priority[i] < currentPriority) {\n          changed = true;\n          currentBurst = burst[i];\n          currentPriority = priority[i];\n          currentProcess = i;\n        }\n      }\n    }\n\n    if (currentBurst === 0 && !changed) {\n      turnaround[currentProcess] = currentTime - initialArrival[currentProcess];\n      waiting[currentProcess] = turnaround[currentProcess] - initialBurst[currentProcess];\n      let minPriority = Number.MAX_VALUE;\n      let minProcess = -1;\n\n      for (let i = 0; i < numProcess; ++i) {\n        if (arrived[i] === 1 && priority[i] < minPriority && burst[i] != 0) {\n          minPriority = priority[i];\n          minProcess = i;\n        }\n      }\n\n      currentProcess = minProcess;\n      currentBurst = burst[currentProcess];\n      currentPriority = minPriority;\n      changed = true;\n    }\n\n    if (changed) {\n      firstLine.push(\"P\" + previousProcess.toString());\n\n      if (true) {\n        secondLine.push(currentTime.toString());\n      }\n\n      if (currentTime >= totalTime) {\n        break;\n      }\n    }\n\n    currentTime++;\n    burst[currentProcess]--;\n    currentBurst--;\n  }\n\n  let avgTurnAround = 0;\n  let avgWaiting = 0;\n\n  for (let i = 0; i < numProcess; i++) {\n    avgTurnAround += turnaround[i];\n    avgWaiting += waiting[i];\n  }\n\n  avgTurnAround /= numProcess;\n  avgWaiting /= numProcess;\n  const output = {\n    processSequence: firstLine,\n    timeSequence: secondLine,\n    avgTurnAround: avgTurnAround.toFixed(2),\n    avgWaiting: avgWaiting.toFixed(2),\n    turnAround: turnaround,\n    waiting: waiting\n  };\n  return output;\n};","map":{"version":3,"sources":["/home/skessler/Programming/CPU_Scheduling_simulator/cpu-scheduling-simulator/src/screens/Landing/algorithms/preemptive_priority/index.tsx"],"names":["preemptivePriority","data","currentTime","totalTime","currentProcess","firstLine","secondLine","burst","priority","arrival","numProcess","length","arrived","Array","fill","turnaround","waiting","initialArrival","initialBurst","minArrival","Number","MAX_VALUE","currentPriority","currentBurst","forEach","element","push","parseInt","burstTime","arrivalTime","i","toString","previousProcess","changed","minPriority","minProcess","avgTurnAround","avgWaiting","output","processSequence","timeSequence","toFixed","turnAround"],"mappings":"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","sourcesContent":["// passs in this format: [{process:'1', burstTime'2',arrivalTime:'3',priority:'4'},{process:'1', burstTime'2',arrivalTime:'3',priority:'4'}]\nexport const preemptivePriority = (data: any) => {\n\t// const {process, burstTime, arrivalTime} = data;\n\n\tlet currentTime: number = 0;\n\tlet totalTime: number = 0;\n    let currentProcess:number = -1;\n\tlet firstLine:string[] = [];\n\tlet secondLine: string[] = [];\n\tlet burst: number[] = [];\n    let priority: number[] = [];\n\tlet arrival: number[] = [];\n\tlet numProcess = data.length;\n\tlet arrived: number[] = new Array(numProcess).fill(0);\n\tlet turnaround: number[] = new Array(numProcess).fill(0);\n\tlet waiting: number[] = new Array(numProcess).fill(0);\n\tlet initialArrival: number[] = [];\n\tlet initialBurst: number[] = [];\n\tlet minArrival:number = Number.MAX_VALUE;\n    let currentPriority:number = Number.MAX_VALUE;\n    let currentBurst:number = Number.MAX_VALUE;\n\n\t//get array of burstTime and arrivalTime\n\tdata.forEach((element: any) => {\n\t\tburst.push(parseInt(element.burstTime));\n\t\tinitialArrival.push(parseInt(element.arrivalTime));\n\t\tarrival.push(parseInt(element.arrivalTime));\n\t\tinitialBurst.push(parseInt(element.burstTime));\n        priority.push(parseInt(element.priority))\n\t});\n\n\tfor(let i = 0; i < numProcess; ++i)\n    {\n        if(arrival[i] < minArrival)\n        {\n            minArrival = arrival[i];\n        }\n        totalTime += burst[i];\n        arrived[i] = -1;\n    }\n\tsecondLine.push(minArrival.toString());\n\ttotalTime += minArrival;\n\tcurrentTime += minArrival;\n\n    for(let i = 0; i < numProcess; ++i)\n    {\n        if(arrival[i] === minArrival)\n        {\n            arrived[i] = 1;\n            if(priority[i] <= currentPriority)\n            {\n                currentProcess = i;\n                currentBurst = burst[i];\n                currentPriority = priority[i];\n            }\n        }\n    }\n\n\twhile(currentTime <= totalTime)\n    {\n        let previousProcess:number = currentProcess;\n        let changed:boolean = false;\n        for(let i = 0; i < numProcess; ++i)\n        {\n            if(arrival[i] === currentTime)\n            {\n                arrived[i] = 1;\n                if(priority[i] < currentPriority)\n                {\n                    changed = true;\n                    currentBurst = burst[i];\n                    currentPriority = priority[i];\n                    currentProcess = i;\n                }\n            }\n        }\n        if(currentBurst === 0 && !changed)\n        {\n            turnaround[currentProcess] = currentTime - initialArrival[currentProcess];\n            waiting[currentProcess] = turnaround[currentProcess] - initialBurst[currentProcess];\n            let minPriority:number = Number.MAX_VALUE;\n            let minProcess:number = -1;\n\n            for(let i = 0; i < numProcess; ++i)\n            {\n                if(arrived[i] === 1 && priority[i] < minPriority && burst[i] != 0)\n                {\n                    minPriority = priority[i];\n                    minProcess = i;\n                }\n            }\n            currentProcess = minProcess;\n            currentBurst = burst[currentProcess];\n            currentPriority = minPriority;\n            changed = true;\n        }\n        if(changed)\n        {\n            firstLine.push(\"P\"+previousProcess.toString());\n            if(true)\n            {\n                secondLine.push(currentTime.toString());\n            }\n            if(currentTime >= totalTime)\n            {\n                break;\n            }\n        }\n        currentTime++;\n        burst[currentProcess]--;\n        currentBurst--;\n    }\n\n\tlet avgTurnAround:number = 0;\n\tlet avgWaiting:number = 0;\n\tfor (let i = 0; i < numProcess; i++) {\n\t\tavgTurnAround += turnaround[i];\n\t\tavgWaiting += waiting[i];\n\t}\n\tavgTurnAround /= numProcess;\n\tavgWaiting /= numProcess;\n\n\tconst output = {\n\t\tprocessSequence: firstLine,\n\t\ttimeSequence: secondLine,\n\t\tavgTurnAround: avgTurnAround.toFixed(2),\n\t\tavgWaiting: avgWaiting.toFixed(2),\n\t\tturnAround: turnaround,\n\t\twaiting: waiting\n\t};\n\treturn output;\n};\n"]},"metadata":{},"sourceType":"module"}