{"ast":null,"code":"export const roundRobin = (data, quantum) => {\n  let currentTime = 0;\n  let totalTime = 0;\n  let count = 0;\n  let q = [];\n  let firstLine = [];\n  let secondLine = [];\n  let burst = [];\n  let arrival = [];\n  let numProcess = data.length;\n  let turnaround = new Array(numProcess).fill(0);\n  let waiting = new Array(numProcess).fill(0);\n  let initialArrival = [];\n  let initialBurst = [];\n  let minArrival = Number.MAX_VALUE; //get array of burstTime and arrivalTime\n\n  data.forEach(element => {\n    burst.push(parseInt(element.burstTime));\n    initialArrival.push(parseInt(element.arrivalTime));\n    arrival.push(parseInt(element.arrivalTime));\n    initialBurst.push(parseInt(element.burstTime));\n  });\n\n  for (let i = 0; i < numProcess; i++) {\n    if (arrival[i] < minArrival) {\n      minArrival = arrival[i];\n    }\n\n    totalTime += burst[i];\n  }\n\n  secondLine.push(minArrival.toString());\n  let temp_pr = new Array();\n  let temp_burst = new Array();\n\n  for (let i = 0; i < numProcess; ++i) {\n    if (arrival[i] === 0) {\n      temp_pr.push(i);\n      temp_burst.push(burst[i]);\n      count = 1;\n    }\n  }\n\n  while (temp_pr.length) {\n    let minBurst = temp_burst[0];\n    let minPr = temp_pr[0];\n    let minIndex = 0;\n\n    for (let i = 1; i < temp_burst.length; ++i) {\n      if (temp_burst[i] < minBurst) {\n        minBurst = temp_burst[i];\n        minPr = temp_pr[i];\n        minIndex = i;\n      }\n    }\n\n    q.push(temp_pr[minIndex]);\n    temp_pr.splice(minIndex, 1);\n    temp_burst.splice(minIndex, 1);\n  } //Main Loop\n\n\n  while (currentTime <= totalTime) {\n    currentTime++; // Checking for multiple processes arriving at the same and arranging them according to burst time.\n\n    for (let i = 0; i < numProcess; ++i) {\n      if (arrival[i] === currentTime) {\n        temp_pr.push(i);\n        temp_burst.push(burst[i]);\n      }\n    }\n\n    while (temp_pr.length) {\n      let minBurst = temp_burst[0];\n      let minPr = temp_pr[0];\n      let minIndex = 0;\n\n      for (let i = 1; i < temp_burst.length; ++i) {\n        if (temp_burst[i] < minBurst) {\n          minBurst = temp_burst[i];\n          minPr = temp_pr[i];\n          minIndex = i;\n        }\n      }\n\n      q.push(temp_pr[minIndex]);\n      temp_pr.splice(minIndex, 1);\n      temp_burst.splice(minIndex, 1);\n    }\n\n    if (currentTime > minArrival) {\n      burst[q[0] === undefined ? 0 : q[0]]--;\n    }\n\n    if (burst[q[0] === undefined ? 0 : q[0]] === 0) {\n      var _ref;\n\n      // console.log(\"q in if \",q[0] === undefined?0:q[0])\n      turnaround[q[0] === undefined ? 0 : q[0]] = currentTime - initialArrival[q[0] === undefined ? 0 : q[0]];\n      waiting[q[0] === undefined ? 0 : q[0]] = turnaround[q[0] === undefined ? 0 : q[0]] - initialBurst[q[0] === undefined ? 0 : q[0]];\n      firstLine.push(\"P\" + ((_ref = q[0] === undefined ? 0 : q[0]) === null || _ref === void 0 ? void 0 : _ref.toString()));\n\n      if (true) {\n        secondLine.push(currentTime.toString());\n      }\n\n      q.shift();\n      count = 0;\n    } else if (count >= quantum) {\n      var _ref2;\n\n      // console.log(\"q in else if \",q[0] === undefined?0:q[0])\n      firstLine.push(\"P\" + ((_ref2 = q[0] === undefined ? 0 : q[0]) === null || _ref2 === void 0 ? void 0 : _ref2.toString()));\n\n      if (true) {\n        secondLine.push(currentTime.toString());\n      }\n\n      q.push(q[0] === undefined ? 0 : q[0]);\n      q.shift();\n      count = 0;\n    }\n\n    count++;\n  }\n\n  let avgTurnAround = 0;\n  let avgWaiting = 0;\n\n  for (let i = 0; i < numProcess; i++) {\n    avgTurnAround += turnaround[i];\n    avgWaiting += waiting[i];\n  }\n\n  avgTurnAround /= numProcess;\n  avgWaiting /= numProcess;\n  const output = {\n    processSequence: firstLine,\n    timeSequence: secondLine,\n    avgTurnAround: avgTurnAround.toFixed(2),\n    avgWaiting: avgWaiting.toFixed(2),\n    turnAround: turnaround,\n    waiting: waiting\n  };\n  return output;\n};","map":{"version":3,"sources":["/home/skessler/Programming/CPU_Scheduling_simulator/cpu-scheduling-simulator/src/screens/Landing/algorithms/round_robin/index.tsx"],"names":["roundRobin","data","quantum","currentTime","totalTime","count","q","firstLine","secondLine","burst","arrival","numProcess","length","turnaround","Array","fill","waiting","initialArrival","initialBurst","minArrival","Number","MAX_VALUE","forEach","element","push","parseInt","burstTime","arrivalTime","i","toString","temp_pr","temp_burst","minBurst","minPr","minIndex","splice","undefined","shift","avgTurnAround","avgWaiting","output","processSequence","timeSequence","toFixed","turnAround"],"mappings":"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","sourcesContent":["export const roundRobin = (data: any, quantum:number) => {\n\n\tlet currentTime: number = 0;\n\tlet totalTime: number = 0;\n    let count:number = 0;\n    let q:number[] = [];\n\tlet firstLine:string[] = [];\n\tlet secondLine: string[] = [];\n\tlet burst: number[] = [];\n\tlet arrival: number[] = [];\n\tlet numProcess = data.length;\n\tlet turnaround: number[] = new Array(numProcess).fill(0);\n\tlet waiting: number[] = new Array(numProcess).fill(0);\n\tlet initialArrival: number[] = [];\n\tlet initialBurst: number[] = [];\n\tlet minArrival:number = Number.MAX_VALUE;\n\n\t//get array of burstTime and arrivalTime\n\tdata.forEach((element: any) => {\n\t\tburst.push(parseInt(element.burstTime));\n\t\tinitialArrival.push(parseInt(element.arrivalTime));\n\t\tarrival.push(parseInt(element.arrivalTime));\n\t\tinitialBurst.push(parseInt(element.burstTime));\n\t});\n\n\tfor (let i = 0; i < numProcess; i++) {\n\t\tif (arrival[i] < minArrival) {\n\t\t\tminArrival = arrival[i];\n\t\t}\n\t\ttotalTime += burst[i];\n\t}\n\tsecondLine.push(minArrival.toString());\n\t\n    let temp_pr:number[] =  new Array();\n    let temp_burst:number[] = new Array();\n\n    for(let i = 0; i < numProcess; ++i)\n    {\n        if(arrival[i] === 0)\n        {\n            temp_pr.push(i);\n            temp_burst.push(burst[i]);\n            count = 1;\n            \n        }\n    }\n\n\n\twhile (temp_pr.length) {\n\t\tlet minBurst = temp_burst[0];\n        let minPr = temp_pr[0];\n        let minIndex = 0;\n\n        for(let i = 1; i <temp_burst.length; ++i)\n        {\n            if(temp_burst[i] < minBurst)\n            {\n                minBurst = temp_burst[i];\n                minPr = temp_pr[i];\n                minIndex = i;\n            }\n        }\n        q.push(temp_pr[minIndex]);\n        temp_pr.splice(minIndex,1);\n        temp_burst.splice(minIndex,1);\n\t}\n    \n    //Main Loop\n    while(currentTime <= totalTime)\n    {\n        currentTime++;\n\n        // Checking for multiple processes arriving at the same and arranging them according to burst time.\n        for(let i = 0; i < numProcess; ++i)\n        {\n            if(arrival[i] === currentTime)\n            {\n                temp_pr.push(i);\n                temp_burst.push(burst[i]);\n            }\n        }\n\n        while(temp_pr.length)\n        {\n            let minBurst = temp_burst[0];\n            let minPr = temp_pr[0];\n            let minIndex = 0;\n\n            for(let i = 1; i <temp_burst.length; ++i)\n            {\n                if(temp_burst[i] < minBurst)\n                {\n                    minBurst = temp_burst[i];\n                    minPr = temp_pr[i];\n                    minIndex = i;\n                }\n            }\n            q.push(temp_pr[minIndex]);\n\n            temp_pr.splice(minIndex, 1);\n            temp_burst.splice(minIndex,1);\n        }\n\n        if(currentTime > minArrival){\n            burst[q[0] === undefined?0:q[0]]--;\n        }\n\n        if(burst[q[0] === undefined?0:q[0]] === 0)\n        {\n            // console.log(\"q in if \",q[0] === undefined?0:q[0])\n            turnaround[q[0] === undefined?0:q[0]] = currentTime  - initialArrival[q[0] === undefined?0:q[0]];\n            waiting[q[0] === undefined?0:q[0]] = turnaround[q[0] === undefined?0:q[0]] - initialBurst[q[0] === undefined?0:q[0]];\n            firstLine.push(\"P\"+(q[0] === undefined?0:q[0])?.toString());\n            if(true)\n            {\n                secondLine.push(currentTime.toString());\n            }\n            q.shift();\n            count = 0;\n        }\n        else if(count >= quantum)\n        {\n            // console.log(\"q in else if \",q[0] === undefined?0:q[0])\n            firstLine.push(\"P\"+(q[0] === undefined?0:q[0])?.toString());\n            if(true)\n            {\n                secondLine.push(currentTime.toString());\n            }\n            q.push(q[0] === undefined?0:q[0]);\n            q.shift();\n            count = 0;\n        }\n        count++;\n    }\n\n\tlet avgTurnAround = 0;\n\tlet avgWaiting = 0;\n\tfor (let i = 0; i < numProcess; i++) {\n\t\tavgTurnAround += turnaround[i];\n\t\tavgWaiting += waiting[i];\n\t}\n\tavgTurnAround /= numProcess;\n\tavgWaiting /= numProcess;\n\n\tconst output = {\n\t\tprocessSequence: firstLine,\n\t\ttimeSequence: secondLine,\n\t\tavgTurnAround: avgTurnAround.toFixed(2),\n\t\tavgWaiting: avgWaiting.toFixed(2),\n\t\tturnAround: turnaround,\n\t\twaiting: waiting\n\t};\n\n\treturn output;\n};\n"]},"metadata":{},"sourceType":"module"}